# 問題3: フィボナッチ数列 - ヒント

## 問題概要
フィボナッチ数列は、最初の2項が0と1で、その後の項は直前の2項の和になる数列です。
n番目のフィボナッチ数を求める関数を実装する問題です。

## ヒント段階

### 基本ヒント
1. フィボナッチ数列の定義を確認しましょう：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2)
2. 再帰的な方法と反復的な方法の2つのアプローチがあります
3. 負の数が入力された場合のエラー処理を考慮しましょう

### 詳細ヒント（必要な場合）

**再帰的アプローチ**:
- フィボナッチの定義に沿って直接実装できます
- ただし、単純な再帰は重複計算が多く、大きなnに対しては非効率です

```typescript
// 単純な再帰実装（非効率）
function fibonacci(n: number): number {
  // 基本ケース（0と1）
  if (n <= 1) return n;
  
  // 再帰呼び出し
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

**反復的アプローチ**:
- ループを使って、小さいnから順番に計算していく方法
- メモリ効率が良く、大きなnでも高速です

```typescript
// 反復実装（効率的）
function fibonacci(n: number): number {
  // 基本ケース
  if (n <= 1) return n;
  
  // ループで計算
  let a = 0;  // F(0)
  let b = 1;  // F(1)
  let result = 0;
  
  for (let i = 2; i <= n; i++) {
    // 次の値を計算
    // 変数を更新
  }
  
  return /* 最終結果 */;
}
```

**メモ化（再帰の最適化）**:
- 既に計算した値を記憶しておき、再計算を避ける方法
- 再帰の利点を保ちつつ、効率を改善できます

```typescript
// メモ化を使った再帰
function fibonacciMemo(n: number, memo: Record<number, number> = {}): number {
  // メモに結果がある場合は再利用
  
  // 基本ケース
  
  // 結果をメモに保存して返す
}
```

**エラー処理**:
- 負の数が入力された場合はエラーを投げるか、特殊な値を返すべきです
```typescript
if (n < 0) {
  throw new Error("負の数は有効な入力ではありません");
}
```

## 学習ポイント
- 再帰と反復のアプローチの違いと適切な選択
- 時間計算量とスペース計算量の考慮
- メモ化による最適化
- エラー処理と入力検証の重要性 